/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const proxyMarker=Symbol("Comlink.proxy"),createEndpoint=Symbol("Comlink.endpoint"),releaseProxy=Symbol("Comlink.releaseProxy"),finalizer=Symbol("Comlink.finalizer"),throwMarker=Symbol("Comlink.thrown"),isObject=val=>typeof val=="object"&&val!==null||typeof val=="function",proxyTransferHandler={canHandle:val=>isObject(val)&&val[proxyMarker],serialize(obj){const{port1,port2}=new MessageChannel;return expose(obj,port1),[port2,[port2]]},deserialize(port){return port.start(),wrap(port)}},throwTransferHandler={canHandle:value=>isObject(value)&&throwMarker in value,serialize({value}){let serialized;return value instanceof Error?serialized={isError:!0,value:{message:value.message,name:value.name,stack:value.stack}}:serialized={isError:!1,value},[serialized,[]]},deserialize(serialized){throw serialized.isError?Object.assign(new Error(serialized.value.message),serialized.value):serialized.value}},transferHandlers=new Map([["proxy",proxyTransferHandler],["throw",throwTransferHandler]]);function isAllowedOrigin(allowedOrigins,origin){for(const allowedOrigin of allowedOrigins)if(origin===allowedOrigin||allowedOrigin==="*"||allowedOrigin instanceof RegExp&&allowedOrigin.test(origin))return!0;return!1}function expose(obj,ep=globalThis,allowedOrigins=["*"]){ep.addEventListener("message",function callback(ev){if(!ev||!ev.data)return;if(!isAllowedOrigin(allowedOrigins,ev.origin)){console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);return}const{id,type,path}=Object.assign({path:[]},ev.data),argumentList=(ev.data.argumentList||[]).map(fromWireValue);let returnValue;try{const parent=path.slice(0,-1).reduce((obj2,prop)=>obj2[prop],obj),rawValue=path.reduce((obj2,prop)=>obj2[prop],obj);switch(type){case"GET":returnValue=rawValue;break;case"SET":parent[path.slice(-1)[0]]=fromWireValue(ev.data.value),returnValue=!0;break;case"APPLY":returnValue=rawValue.apply(parent,argumentList);break;case"CONSTRUCT":{const value=new rawValue(...argumentList);returnValue=proxy(value)}break;case"ENDPOINT":{const{port1,port2}=new MessageChannel;expose(obj,port2),returnValue=transfer(port1,[port1])}break;case"RELEASE":returnValue=void 0;break;default:return}}catch(value){returnValue={value,[throwMarker]:0}}Promise.resolve(returnValue).catch(value=>({value,[throwMarker]:0})).then(returnValue2=>{const[wireValue,transferables]=toWireValue(returnValue2);ep.postMessage(Object.assign(Object.assign({},wireValue),{id}),transferables),type==="RELEASE"&&(ep.removeEventListener("message",callback),closeEndPoint(ep),finalizer in obj&&typeof obj[finalizer]=="function"&&obj[finalizer]())}).catch(error=>{const[wireValue,transferables]=toWireValue({value:new TypeError("Unserializable return value"),[throwMarker]:0});ep.postMessage(Object.assign(Object.assign({},wireValue),{id}),transferables)})}),ep.start&&ep.start()}function isMessagePort(endpoint){return endpoint.constructor.name==="MessagePort"}function closeEndPoint(endpoint){isMessagePort(endpoint)&&endpoint.close()}function wrap(ep,target){const pendingListeners=new Map;return ep.addEventListener("message",function(ev){const{data}=ev;if(!data||!data.id)return;const resolver=pendingListeners.get(data.id);if(resolver)try{resolver(data)}finally{pendingListeners.delete(data.id)}}),createProxy(ep,pendingListeners,[],target)}function throwIfProxyReleased(isReleased){if(isReleased)throw new Error("Proxy has been released and is not useable")}function releaseEndpoint(ep){return requestResponseMessage(ep,new Map,{type:"RELEASE"}).then(()=>{closeEndPoint(ep)})}const proxyCounter=new WeakMap,proxyFinalizers="FinalizationRegistry"in globalThis&&new FinalizationRegistry(ep=>{const newCount=(proxyCounter.get(ep)||0)-1;proxyCounter.set(ep,newCount),newCount===0&&releaseEndpoint(ep)});function registerProxy(proxy2,ep){const newCount=(proxyCounter.get(ep)||0)+1;proxyCounter.set(ep,newCount),proxyFinalizers&&proxyFinalizers.register(proxy2,ep,proxy2)}function unregisterProxy(proxy2){proxyFinalizers&&proxyFinalizers.unregister(proxy2)}function createProxy(ep,pendingListeners,path=[],target=function(){}){let isProxyReleased=!1;const proxy2=new Proxy(target,{get(_target,prop){if(throwIfProxyReleased(isProxyReleased),prop===releaseProxy)return()=>{unregisterProxy(proxy2),releaseEndpoint(ep),pendingListeners.clear(),isProxyReleased=!0};if(prop==="then"){if(path.length===0)return{then:()=>proxy2};const r=requestResponseMessage(ep,pendingListeners,{type:"GET",path:path.map(p=>p.toString())}).then(fromWireValue);return r.then.bind(r)}return createProxy(ep,pendingListeners,[...path,prop])},set(_target,prop,rawValue){throwIfProxyReleased(isProxyReleased);const[value,transferables]=toWireValue(rawValue);return requestResponseMessage(ep,pendingListeners,{type:"SET",path:[...path,prop].map(p=>p.toString()),value},transferables).then(fromWireValue)},apply(_target,_thisArg,rawArgumentList){throwIfProxyReleased(isProxyReleased);const last=path[path.length-1];if(last===createEndpoint)return requestResponseMessage(ep,pendingListeners,{type:"ENDPOINT"}).then(fromWireValue);if(last==="bind")return createProxy(ep,pendingListeners,path.slice(0,-1));const[argumentList,transferables]=processArguments(rawArgumentList);return requestResponseMessage(ep,pendingListeners,{type:"APPLY",path:path.map(p=>p.toString()),argumentList},transferables).then(fromWireValue)},construct(_target,rawArgumentList){throwIfProxyReleased(isProxyReleased);const[argumentList,transferables]=processArguments(rawArgumentList);return requestResponseMessage(ep,pendingListeners,{type:"CONSTRUCT",path:path.map(p=>p.toString()),argumentList},transferables).then(fromWireValue)}});return registerProxy(proxy2,ep),proxy2}function myFlat(arr){return Array.prototype.concat.apply([],arr)}function processArguments(argumentList){const processed=argumentList.map(toWireValue);return[processed.map(v=>v[0]),myFlat(processed.map(v=>v[1]))]}const transferCache=new WeakMap;function transfer(obj,transfers){return transferCache.set(obj,transfers),obj}function proxy(obj){return Object.assign(obj,{[proxyMarker]:!0})}function toWireValue(value){for(const[name,handler]of transferHandlers)if(handler.canHandle(value)){const[serializedValue,transferables]=handler.serialize(value);return[{type:"HANDLER",name,value:serializedValue},transferables]}return[{type:"RAW",value},transferCache.get(value)||[]]}function fromWireValue(value){switch(value.type){case"HANDLER":return transferHandlers.get(value.name).deserialize(value.value);case"RAW":return value.value}}function requestResponseMessage(ep,pendingListeners,msg,transfers){return new Promise(resolve=>{const id=generateUUID();pendingListeners.set(id,resolve),ep.start&&ep.start(),ep.postMessage(Object.assign({id},msg),transfers)})}function generateUUID(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}export{proxy as p,wrap as w};
